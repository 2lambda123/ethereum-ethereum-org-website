---
title: 以太坊白皮書
description: 以太坊的介紹論文，2013年在以太坊啟動前發布。
lang: zh-tw
sidebarDepth: 2
hideEditButton: true
---

# 以太坊白皮書 {#ethereum-whitepaper}

_這篇介紹論文最初由[以太坊](/zh/what-is-ethereum/)創始人 Vitalik Buterin 在 2014 年發表，前於 2015 年的專案正式發佈時間。 值得一提的是，和其他社群驅動的開源軟體專案一樣，以太坊自發布以來一直不斷發展。_

_雖然已經過數年，但由於本文仍然可提供有用的參考並能夠準確表述以太坊及其願景，我們仍然在維護它。 若想了解以太坊的最新進展，以及以太坊協議的更新情況，我們推薦您閱讀[本指南](/learn/)。_

[尋求此白皮書早期版本或規範版本 [自 2014 年 12 月起] 的研究人員和學者應使用此 PDF。](./whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf)

## 下一代智慧合約與去中心化應用平台 {#a-next-generation-smart-contract-and-decentralized-application-platform}

中本聰2009 年開發的比特幣常被譽為資金和貨幣的革命性變革，作為數位資產的首個實例，它同時具有以下特點：沒有實物或[內在價值](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/)支撐，也沒有一個中心化 的發行機構或控制者。 然而，比特幣實驗有另一個可以說是更重要的部分，即作為分散式共識工具的底層區塊鏈技術，而人們的注意力正迅速地開始轉移到比特幣的這個面向。 其他經常被提及的區塊鏈技術應用包括：使用鏈上數位資產表示自訂貨幣和金融工具（「[彩色幣](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)」）、底層實體設備的所有權（「[智慧資產](https://en.bitcoin.it/wiki/Smart_Property)」）、非同質性網域資產例如網域名稱（[域名幣](http://namecoin.org)」），以及一些更複雜的應用，例如讓數位資產由一段實現任意規則的程式碼（「[智能合約](http://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html)」）甚至由基於區塊鏈的「[去中心化自治組織](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)」(DAO) 直接控制。 以太坊打算提供一種內建完全成熟的圖靈完備程式語言的區塊鏈，這種語言可用於創建“合約”，而合約可用於編碼任意狀態轉換函數，讓用戶可以創建上述任何系統以及我們尚未 想像到的許多其他內容，只需用幾行程式碼寫出想實現的邏輯即可。

## 比特幣及現有概念簡介 {#introduction-to-bitcoin-and-existing-concepts}

### 歷史 {#history}

去中心化數位貨幣的概念以及財產登記等其他應用程式已經存在了幾十年。 1980 年代和1990 年代的匿名電子現金協議主要依賴稱為Chaumian 盲簽名的密碼學原語，提供了一種具有高度隱私性的貨幣，但這些協議基本上未能獲得關注，因為它們依賴於中心 化中介。 1998 年，戴偉(Wei Dai) 的[b-money](http://www.weidai.com/bmoney.txt) 成為第一個提出透過解決計算難題來創造貨幣及去中心化共識等想法的 協議，但該協議缺乏關於如何實際實施去中心化共識的細節。 2005 年，Hal Finney 引入了「[可重複使用的工作量證明](https://nakamotoinstitute.org/finney/rpow/)」這個概念，該系統將b-money 的想法與Adam Back 有計算難度 的哈希現金難題相結合來創建加密貨幣的概念，但由於依賴可信計算作為後端，又一次未能做到完美。 2009 年，中本聰將透過公鑰密碼學管理所有權的成熟原語與用於追蹤貨幣所有者的共識演算法相結合，首次真正意義上實現了一種去中心化貨幣，被稱為「工作量 證明」。

工作量證明機制是該領域的突破，因為它同時解決了兩個問題。 首先，它提供了一種簡單且比較有效的共識演算法，讓網路中的節點能夠全體對比特幣帳本狀態的一組規範更新達成協議。 其次，它提供了一種允許自由進入共識過程的機制，解決了決定誰來影響共識的政治問題，同時防止了女巫攻擊。 為此，在工作量證明中，將正式的參與壁壘（例如要求在特定清單上註冊成為唯一實體）替換成經濟壁壘，即共識投票過程中單一節點的權重與該節點的算力成正比。 此後，也提出了另一種稱為*權益證明*的方法，節點權重與其貨幣持有量而非計算資源成正比；針對這兩種方法相對優點的討論不在本文範圍內，但應該注意，這 兩種方法都可以作為加密貨幣的支柱。

### 比特幣是一個狀態轉換系統 {#bitcoin-as-a-state-transition-system}

![以太坊狀態轉換](./ethereum-state-transition.png)

從技術角度講，諸如比特幣等加密貨幣帳本可視化一種狀態轉換系統，該系統具有“狀態”，由全部現存比特幣的所有權狀態和一個“狀態轉換函數”組成，狀態轉換函數以 狀態和交易為輸入並輸出新狀態作為結果。 例如，在標準的銀行系統中，狀態就是一個資產負債表，一筆交易是一個從A 帳戶向B 帳戶轉帳$X的請求，狀態轉換函數將從A帳戶中減去$X，向B 帳戶增加 $X。 如果A帳戶的餘額在第一步驟小於$X，狀態轉換函數就會傳回錯誤提示。 所以，可以如此定義：

```
APPLY(S,TX) -> S' 或 ERROR
```

在上述的銀行系統中，狀態轉換函數如下：

```js
APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
```

但是：

```js
APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
```

比特幣中的「狀態」是指所有已鑄造但尚未使用的貨幣（技術上稱為「未使用的交易輸出」或UTXO）的集合，每個UTXO 都有面額和所有者（由一個20 位元組 的位址定義，本質上是一個加密公鑰<sup>[fn1]（註解編號）</sup>）。 一個交易包括一個或多個輸入以及一個或多個輸出，每個輸入都包含對現有UTXO 的引用以及所有者地址相關的私鑰創建的加密簽名；每個輸出都包含一個要添加到狀態中 的新UTXO。

狀態轉換函數 `APPLY(S,TX) -> S'` 的定義大致如下：

<ol>
   <li>
     對於 <code>TX</code> 中的每個輸入：
     <ul>
     <li>
         如果引用的 UTXO 不在 <code>S</code> 範圍內，則傳回錯誤。
     </li>
     <li>
         如果提供的簽章與 UTXO 的擁有者不符合，則傳回錯誤。
     </li>
     </ul>
   </li>
   <li>
     如果所有輸入 UTXO 面值總額小於所有輸出 UTXO 面值總額，則傳回錯誤。
   </li>
   <li>
     移除所有輸入 UTXO 且新增所有輸出 UTXO 後，返回 <code>S</code>。
   </li>
</ol>

第一步的第一部分防止交易發送者花費不存在的比特幣，第二部分防止交易發送者花費其他人的比特幣，第二步確保價值守恆。 為了用於支付，比特幣協議如下。 假設 Alice 想寄給 Bob 11.7 BTC。 首先，Alice 將尋找她擁有的一組總數至少為 11.7 BTC 的可用 UTXO。 事實上，Alice 不太可能正好有 11.7 BTC；假設她能得到的最小金額是 6+4+2=12。 所以，她可以創建一筆有三個輸入和兩個輸出的交易。 第一個輸出為 11.7 BTC，所有者是 Bob 的地址，第二個輸出為剩下的 0.3 BTC 找零，所有者是 Alice 自己。

### 挖礦 {#mining}

![以太坊區塊](./ethereum-blocks.png)

如果我們擁有可信任的中心化服務機構，狀態轉換系統可以輕鬆實現；可以簡單地將上述功能準確編碼，使用中心化伺服器的硬碟來記錄狀態。 然而，我們想把比特幣建構成去中心化貨幣系統，為了確保每個人都同意交易的順序，我們需要將狀態轉換系統與共識系統結合。 比特幣的去中心化共識進程要求網路中的節點不斷嘗試將交易打包成「區塊」。 網路計畫大約每十分鐘產生一個區塊，每個區塊包含一個時間戳記、一個隨機數、一個對上一個區塊的引用（即哈希）和上一區塊生成以來發生的所有交易清單。 隨著時間推移就創建了一個持續增長的區塊鏈，它不斷地更新，從而能夠代表比特幣帳本的最新狀態。

檢查一個區塊是否有效的演算法，如以下範式所示：

1. 檢查該區塊引用的上一個區塊是否存在且有效。
2. 檢查該區塊的時間戳記是否大於上一個區塊 <sup>[fn2]（註釋編號）</sup>的時間戳記並且在將來 2 小時以內
3. 檢查區塊上的工作量證明是否有效。
4. 令前一個區塊末的態為 `S[0]`。
5. 假設 `TX` 是該區塊的交易列表，其中包含 `n` 個交易。 對於`0...n-1` 中的所有`i`，如果有任何應用程式回傳錯誤，退出並傳回false，請設定`S[i+1] = APPLY(S[i],TX[i ])`。
6. 傳回 true，並將 `S[n]` 登記為該區塊末端的狀態。

本質上，區塊中的每筆交易都必須提供一個有效的狀態轉換，從交易執行前的規範狀態轉換到某個新狀態。 注意，狀態並未編碼到區塊。 它純粹只是校驗節點記住的抽象概念，只能被任意區塊從創世狀態開始，按順序加上每個區塊的每一筆交易，（安全地）計算出當前狀態。 另外，需要注意礦工將交易收錄進區塊的順序。 如果一個區塊中有 A、B 兩筆交易，B 花費的是 A 創建的 UTXO，如果 A 在 B 之前，這個區塊是有效的，否則，這個區塊無效。

「工作量證明」是出現在上表而其他系統沒有的驗證條件。 具體驗證方法為，對每個區塊進行兩次SHA256 雜湊處理，得到一個256 位元的數值，該數值必須小於不斷動態調整的目標數值，本文寫作時目標數值大約是2<sup>187</ sup>。 工作量證明的目的是使創建區塊有算力困難，從而阻止女巫攻擊者惡意重新生成區塊鏈。 因為 SHA256 是完全不可預測的偽隨機函數，創建有效區塊的唯一方法就是簡單地不斷試錯，不斷增加隨機數的數值，查看新的雜湊數是否小於目標值。

目前的目標數值是\~2<sup>187</sup>，網路必須平均嘗試 \~2<sup>69</sup>次才能產生有效的區塊。 一般而言，比特幣網路每 2016個區塊重新設定目標數值，從而保證網路中的節點平均每十分鐘產生一個區塊。 為了對礦工的計算工作進行激勵，每個成功生成區塊的礦工有權在區塊中包含一筆憑空發給他們自己 12.5 BTC 的交易。 另外，如果交易的輸入額大於輸出，差額部分就作為「交易費」付給礦工。 順便提一下，這也是比特幣發行的唯一機制，創世狀態中並沒有比特幣。

為了更好地理解挖礦的目的，讓我們分析比特幣網路出現惡意攻擊者時會發生什麼事。 因為比特幣的密碼學基礎是非常安全的，所以攻擊者會選擇攻擊沒有被密碼學直接保護的部分：交易順序。 攻擊者的策略非常簡單：

1. 向商家發送 100 個比特幣以換取某種產品（最好是快速交付的數位商品）
2. 等待商品交付
3. 創建另一筆交易，將這 100 個比特幣發送給自己
4. 試圖讓網路相信他對自己的交易是先發生的。

一旦步驟 (1) 發生，幾分鐘後礦工將這筆交易收錄到區塊中，假設是編號為 270000 的區塊。 大約一小時後，此區塊後面將會有五個區塊，每個區塊間接指向這筆交易，從而確認這筆交易。 這時賣家收到貨款，並向買家出貨。 因為我們假設這是數位商品，交付將瞬間完成。 現在，攻擊者會建立另一筆交易，將相同的 100BTC 傳送到自己的帳戶。 如果攻擊者只是單純地向全網廣播這一訊息，該筆交易不會被處理；礦工將運行狀態轉換函數 `APPLY(S,TX)` ，發現這筆交易要花費已經不在狀態中的 UTXO。 所以，攻擊者會對區塊鏈進行分叉，將第 269 個區塊作為父區塊重新生成第 270 個區塊，在此區塊中用新交易取代舊的。 因為區塊資料是不同的，這要求重新進行工作量證明。 另外，攻擊者的新版 270 區塊有不同的哈希，原來的 271 到 275 的區塊不指向它，所以原鍊和攻擊者的新鏈是完全分離的。 規定，在發生區塊鏈分叉時，最長鏈被認為是誠實的區塊鏈，合法的礦工將會沿著原有的275 區塊挖礦，只有攻擊者一人在新的270 區塊後 挖礦。 攻擊者為了使其區塊鏈最長，他需要擁有比除了他以外的全網更多的算力來追趕（即「51%攻擊」）。

### 梅克爾樹 {#merkle-trees}

![比特幣簡化付款確認](./spv-bitcoin.png)

_左：僅提供默克爾樹上的少量節點已經足夠給出分支的合法證明。_

_右：對默克爾樹任意部分進行改變的嘗試最終都會導致鏈上某處不一致。_

比特幣一個重要的可擴展特性是：它的區塊儲存在多層次資料結構中。 一個區塊的哈希實際上只是區塊頭的哈希，區塊頭是一段約200 位元組的數據，包含時間戳記、隨機數、上個區塊的哈希和默克爾樹根的哈希， 而默克爾樹是一個儲存了該區塊所有交易的資料結構。 梅克爾樹是一種二元樹，由一組葉節點、一組中間節點和一個根節點構成。 最下面是大量包含基礎資料的葉節點，每個中間節點是其兩個子節點的哈希，頂部的根節點也是其兩個子節點的哈希。 梅克爾樹的目的是允許區塊資料可以零散地傳送：節點可以從一個來源下載區塊頭，從其它來源下載相關樹的一小部分，而仍然能夠確認所有的資料都是正確的。 之所以如此是因為哈希向上傳播：如果一個惡意用戶嘗試替換一個偽造的交易到樹的底部，此改動將導致樹的上層節點的改動，以及更上層節點的改動，最終導致根節點的改動以及 區塊哈希的改動，這樣協議就會將其記錄為一個完全不同的區塊（幾乎可以肯定是帶著無效的工作量證明）。

梅克爾樹協議可以說是比特幣長期持續性的基礎。 比特幣網路中的一個全節點——儲存和處理所有區塊全部資料的節點，在 2014 年 4 月需要佔用 15GB 的磁碟空間，而且還以每個月超過 1GB 的速度成長。 目前，對桌上型電腦來說尚可接受，但是手機已經負載不瞭如此巨大的數據了，未來只有商業機構和愛好者才會充當完整節點。 簡化支付確認協議（SPV）允許另一種節點存在，這樣的節點被稱為“輕節點”，它下載區塊頭，使用區塊頭確認工作量證明，然後只下載與其交易相關的默克爾樹分支 。 這使得輕節點只要下載整個區塊鏈的一小部分，就可以安全地確定任何一筆比特幣交易的狀態和帳戶的當前餘額。

### 其它的區塊鏈應用 {#alternative-blockchain-applications}

將區塊鏈思想應用到其它領域的想法早就出現了。 2005 年，Nick Szabo 提出了「[利用所有者權限確保財產權](https://nakamotoinstitute.org/secure-property-titles/)」這一概念，該文件描述了「複製資料庫技術的新進展」將 如何允許基於區塊鏈的系統儲存誰擁有哪些土地的登記表，創建了一個包括宅基地、違法佔有和喬治亞州土地稅等概念的複雜框架。 然而，不幸的是在那時還沒有實用的複製資料庫系統，所以這個協議沒有被付諸實行。 不過，自 2009 年比特幣的去中心化共識開發成功以來，大量區塊鏈的其它應用開始快速出現。

- **域名幣** - 創建於 2010 年，[域名幣](https://namecoin.org/)描述成去中心化的名稱註冊資料庫最為恰當。 在Tor、比特幣和比特信等去中心化協議中，需要某種方式來識別帳戶，以便其他人可以與帳戶交互，但在所有現有解決方案中，唯一可用的識別碼是偽隨機哈希 ，如`1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy`。 理想情況下，人們希望能夠擁有名稱的帳戶，例如「george」。 但是，問題在於如果一個人可以建立名為「george」的帳戶，那麼其他人也可以以相同流程為自己註冊「george」來冒充。 唯一的解決方案是「成果優先原則」範式，即第一個註冊者成功後第二個註冊者將失敗，這個問題非常適合比特幣共識協議。 域名幣是應用這種想法的最早、最成功的名稱註冊系統實現。
- **彩色幣** - [彩色幣](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)的作用是充當一種協議，讓人們在比特幣 區塊鏈上創建自己的數位貨幣，或者在貨幣只有一個單位的這種重要但瑣碎情況下，創建數位代幣。 在彩色幣協議中，透過公開為特定的比特幣UTXO 分配一種顏色來「發行」新貨幣，並且該協議以遞歸方式將其他UTXO 的顏色定義為與創建它們的交易所花費的輸入的顏色相同 （一些特殊規則適用於混合顏色輸入的情況）。 這樣，用戶可以維護僅包含特定顏色 UTXO 的錢包，像發送普通比特幣一樣發送它們，並透過區塊鏈回溯以確定他們收到的任何 UTXO 的顏色。
- **元幣** - 元幣是想要擁有一個基於比特幣的協議，使用比特幣交易來儲存元幣交易，但具有不同的狀態轉換函數 `APPLY'`。 因為元幣協議無法阻止無效元幣交易出現在比特幣區塊鏈中，所以增加了一條規則，如果`APPLY'(S,TX)` 回傳錯誤，則該協議預設為`APPLY'( S,TX) = S`。 這為創建任意加密貨幣協議提供了一種簡單的機制，可能有無法在比特幣內部實現的高級功能，但開發成本非常低，因為比特幣協議已經處理了挖礦和網路的複雜性。 元幣已被用於實現某些類別的金融合約、名稱註冊和去中心化交易所。

因此，一般而言，建立共識協議有兩種方法：建立一個獨立網路或把協議建立在比特幣網路上。 前一種方法在域名幣這樣的應用中相當成功，但是該方法的實施非常困難，每個應用都要創建獨立的區塊鏈，建立並測試所有必須的狀態轉換函數和網絡代碼。 另外，我們預測去中心化共識技術應用將會服從冪律分佈，大多數的應用太小不足以保證自身的安全，我們還注意到大量的去中心化應用，尤其是去中心化自治組織，需要 進行應用之間的互動。

另一方面，基於比特幣的方法有缺點，它沒有繼承比特幣簡化確認支付（SPV) 的特性。 比特幣可以實現簡化確認支付，因為比特幣可以用區塊鏈深度代表有效性；某種程度上，當一筆交易的祖先們距離現在足夠遠時，就可以安全地認為它們是合法狀態的一部分 。 與之相反，基於比特幣區塊鏈的元幣協議不能強迫區塊鏈剔除違反元幣協議的交易。 因此，完全安全的元幣協議的簡化支付確認需要後向掃描所有的區塊，直到比特幣區塊鏈的初始點，以確認某一交易是否有效。 目前，所有基於比特幣的元幣協議的「輕」實施都依賴可信任的伺服器提供數據，這對主要目的之一是消除信任需求的加密貨幣而言，可能是一個相當次優的結果。

### 腳本 {#scripting}

即使不對比特幣協議進行擴展，它也能在一定程度上實現」智能合約」。 比特幣的 UTXO 並非只能被公鑰擁有，也可以被基於堆疊的程式語言所編寫的更複雜的腳本所擁有。 在這一模式下，花費這樣的 UTXO，必須提供滿足腳本的資料。 事實上，甚至基本的公鑰所有權機制也是透過腳本實現的：腳本將橢圓曲線簽名作為輸入，驗證該交易和擁有此 UTXO 的地址，如果驗證成功則傳回 1，否則傳回 0。 其它更複雜的腳本用於各種不同的應用情況。 例如，人們可以創建要求集齊三個私鑰簽名中的兩個才能進行交易確認的腳本（多重簽名），對公司帳戶、安全儲蓄帳戶和某些商業代理來說，這種腳本是非常有用的 。 腳本也能用來支付解決計算問題的獎勵，人們甚至可以創建這樣的腳本“如果你能夠提供你已經發送一定數額的狗幣給我的簡化確認支付證明，該比特幣UTXO 就是你的了”， 本質上，比特幣系統允許不同的加密貨幣進行去中心化交易。

然而，比特幣系統的腳本語言存在一些嚴重的限制：

- **缺乏圖靈完備性** - 也就是說，雖然比特幣腳本語言支援一個很大的計算子集，但它基本上不支援所有計算。 缺少的主要類別是循環。 這樣做是為了避免在交易驗證期間出現無限循環；理論上，對腳本程式設計師來說循環是一個可以克服的障礙，因為任何循環都可以透過簡單地使用if 語句多次重複執行底層程式碼來模擬，但 這確實會導致腳本的空間效率非常低。 例如，實作另一種橢圓曲線簽名演算法可能需要 256 次重複的乘法，而每次都需要單獨寫在程式碼裡。
- **價值盲** - UTXO 腳本無法對可提取金額進行精細控制。 例如，預言機合約的一個強有力的用例是對沖合約，其中 A 和 B 存入價值 $1000 的比特幣，30 天後腳本將價值 $1000 的比特幣發送給 A，其餘的發送給 B。 這需要預言機來確定 1 個比特幣的美元價值，但即便如此，與現有完全集中化的解決方案相比，這在信任和基礎設施要求方面仍是一個巨大的進步。 然而，由於UTXO 要么是全部要么是零，要實現這一目標，只能使用非常低效的破解方法，即持有許多不同面額的UTXO（例如，面額為2<sup>k</sup> 的 UTXO，每個k 值都可以達到30）並讓預言機選擇發送給A 和發送給B 的UTXO。
- **缺少狀態** - UTXO 可以是已使用或未使用；用於保存任何其他內部狀態的多階段合約或腳本是沒有機會出現的。 這使得多階段選擇權合約、去中心化交易報價或兩階段加密承諾協議（這是安全計算賞金所必需的）難以創建。 這也意味著 UTXO 只能用於建立簡單的一次性合約，而不是去中心化組織等更複雜的「有狀態」合約，使得元協議難以實現。 二元狀態加上價值盲也意味著另一個重要應用 — 提款限制 — 是不可能實現的。
- **區塊鏈盲** - UTXO 看不到區塊鏈的數據，例如隨機數、時間戳記和上一個區塊的雜湊。 由於該腳本語言無法透過隨機性來創造可能的價值，因此它在博彩和其他幾個類別的應用受到了嚴重限制。

至此，我們已經考察了在加密貨幣上建立進階應用的三種方法：建立一個新的區塊鏈、在比特幣區塊鏈上使用腳本、在比特幣區塊鏈上建立元幣協議。 建立新區塊鏈的方法可以自由地實現任意的特性，但要付出開發時間、引導工作和安全性的代價。 使用腳本的方法容易實施和標準化，但是它的功能有限。 元幣協議儘管非常容易實現，但是存在擴展性差的缺陷。 在以太坊系統中，我們打算建立一個替代框架，讓開發更便利、輕客戶端效能更強大，同時允許應用程式共享經濟環境和區塊鏈安全性。

## 以太坊 {#ethereum}

以太坊的目的是創建一個用於建立去中心化應用的替代協議，我們認為提供一套不同的折衷方案對大量去中心化應用非常有用，尤其是那些強調快速開發、小型和不常用應用的安全 性，以及應用間高效互動能力的程序。 以太坊透過建構本質上是最終的抽象基礎層來實現這一點：一種內建圖靈完備程式語言的區塊鏈，允許任何人編寫智慧合約和去中心化應用，並在其中設立他們自由定義的 所有權規則、交易方式和狀態轉換函數。 域名幣的主體框架只需要兩行程式碼就可以實現，諸如貨幣和信譽系統等其它協議只需要不到二十行程式碼就可以實現。 智能合約，即包含價值、只有在滿足特定條件時才能解鎖的加密“盒子”，也可以在平台上構建，並且因為圖靈完備性、價值知曉（value-awareness）、區塊鏈知曉（blockchain- awareness）和多狀態所增加的力量，而比比特幣腳本所能提供的智能合約強大得多。

### 以太坊帳戶 {#ethereum-accounts}

在以太坊中，狀態由稱為「帳戶」的物件組成，而每個帳戶都有一個 20 位元組的位址，狀態轉換是指帳戶之間價值和資訊的直接轉移。 一個以太坊帳戶包含四個欄位：

- **nonce**，用於確保每筆交易只能處理一次的計數器
- 帳戶當前的**以太幣餘額**
- 帳戶的**合約代碼**（若有）
- 帳戶的**儲存**（預設為空）

以太幣是以太坊內部的主要加密燃料，用於支付交易費用。 通常有兩類帳戶：由私鑰控制的**外部帳戶**以及由其合約程式碼控制的**合約帳戶**。 外部帳戶沒有代碼，持有者可以透過建立和簽署交易從外部帳戶發送訊息；在合約帳戶中，每次合約帳戶收到訊息時，其代碼都會激活，允許該帳戶讀取和寫入內部存儲， 繼而發送其他訊息或創建合約。

請注意，以太坊中的「合約」不應被視為要「履行」或「遵守」的東西；相反，合約更像是存在於以太坊執行環境中的「自治代理」。 當被交易或訊息「觸發」時，合約總是執行特定的程式碼段，並直接控制自已的以太幣餘額和鍵/值存儲，以追蹤永久變數。

### 訊息和交易 {#messages-and-transactions}

在以太坊中，術語「交易」用來指已簽署的資料包，資料包儲存著將要從外部帳戶發送的訊息。 交易包含：

- 訊息接收者
- 用於識別發送者身分的簽名
- 從發送者轉帳到接收者的以太幣金額
- 一個可選資料字段
- `STARTGAS` 值，表示允許交易運行的最大計算步驟數
- `GASPRICE` 值，表示發送者每個計算步驟所支付的費用

前三個是任何加密貨幣都有的標準欄位。 預設情況下，資料欄位沒有函數，但虛擬機器有一個操作碼，合約可以使用該操作碼存取資料；以這樣的用例為例：如果一個合約作為區塊鏈上的網域註冊服務，那麼它可能希望 將傳送給它的資料解釋為包含兩個“欄位”，第一個欄位是要註冊的域名，第二個欄位將網域註冊到IP 位址。 合約將從訊息資料中讀取這些值，並將其適當地儲存。

`STARTGAS` 和 `GASPRICE` 欄位對於以太坊的反拒絕服務模型至關重要。 為了防止程式碼中出現無意或惡意的無限循環或其他計算浪費，要求每筆交易對程式碼可以執行的計算步驟設定一個限制。 計算的基本單位是燃料；通常，一個計算步驟消耗 1 份燃料，但某些操作會消耗更多燃料，因為它們在計算上更加昂貴或增加了必須儲存到狀態中的資料量。 交易資料中的每個位元組還需支付的費用為 5 份燃料。 收費系統的意圖是要求攻擊者相應支付他們消耗的每一種資源，包括運算、頻寬和儲存；因此，任何導致網路消耗更多這些資源的交易，都必須支付大致與增加量成比例的燃料費用 。

### 訊息 {#messages}

合約能夠向其他合約發送「訊息」。 訊息是從未序列化的虛擬對象，只存在於以太坊執行環境。 訊息包含：

- 訊息發送者（隱含的）
- 訊息接收者
- 隨訊息一起轉帳的以太幣金額
- 一個可選資料字段
- `STARTGAS` 值

本質上訊息類似於交易，只是訊息是由合約而非外部參與者產生的。 目前正在執行程式碼的合約執行 `CALL` 操作碼時會產生一則訊息，該操作碼就是用來產生並執行訊息。 像交易一樣，資訊導致接收者帳戶運行其代碼。 因此，合約之間可以建立關係，方式完全與外部參與者之間建立關係相同。

請注意，為交易或合約分配的燃料配額適用於該交易和所有子執行消耗的總燃料量。 例如，如果外部參與者A 向B 發送一筆配額為1000 份燃料的交易，B 在向C 發送訊息需要消耗600 份燃料，而C 在內部執行需要消耗300 份燃料才能返回結果，那麼B 再發送 100 份燃料就會消耗完燃料。

### 以太坊狀態轉換函數 {#ethereum-state-transition-function}

![以太幣狀態轉換](./ether-state-transition.png)

以太坊狀態轉換函數 `APPLY(S,TX) -> S'` 可如下定義：

1. 檢查交易格式是否正確（即具有正確數量的值）、簽章是否有效以及 Nonce 值是否與發送者帳戶中的 Nonce 值相符。 若否，則回傳錯誤。
2. 透過 `STARTGAS * GASPRICE` 計算交易費，並從簽章確定發送地址。 從發送者的帳戶餘額中減去費用，並增加發送者的 nonce 值。 如果帳戶餘額不足，則傳回錯誤。
3. 初始化 `GAS = STARTGAS`，並根據交易中的位元組數量為每個位元組扣除相應數量的燃料。
4. 將交易數值從發送者帳戶轉移至接收帳戶。 如果接收帳戶尚不存在，則建立此帳戶。 如果接收帳戶是合約，請執行該合約的程式碼，直到程式碼運行結束或燃料耗盡。
5. 如果由於發送者資金不足或代碼運行耗盡了燃料，而導致轉帳失敗，則回滾除支付費用之外的所有狀態變化，並將費用支付給礦工帳戶。
6. 否則，將所有剩餘燃料的費用退還給發送者，並把為所消耗燃料而支付的費用發送給礦工。

例如，假設合約的程式碼如下：

```py
if !self.storage[calldataload(0)]:
   self.storage[calldataload(0)] = calldataload(32)
```

請注意，合約程式碼實際上是用低階以太坊虛擬機程式碼編寫的；為了清晰起見，此範例是用我們的一種高階語言 Serpent 編寫的，它可以編譯為以太坊虛擬機程式碼。 假設合約的儲存一開始是空的，發送了一個價值為10 個以太幣的交易，消耗2000 份燃料，燃料價格為0.001 個以太幣，並且數據包含64 個字節，字節0-31 代表數字 `2`，位元組32-63 代表字串`CHARLIE`。 在這種情況下，狀態轉換函數的執行過程如下：

1. 檢查交易是否有效、格式是否正確。
2. 檢查交易發送者是否至少有 2000 \* 0.001 = 2 個以太幣。 若有，則從發送者帳戶扣除 2 個以太幣。
3. 初始化燃料 = 2000 份，假設交易長度為 170 個位元組，每位元組費用 5 份燃料，減去 850 份燃料，剩下 1150 份燃料。
4. 從發送者帳戶再減去 10 個以太幣並增加到合約帳戶。
5. 運行程式碼。 在本例中，執行比較簡單：程式碼檢查是否使用合約的索引 `2` 處的存儲，若未使用，則通知；若使用，程式碼將索引 `2` 處的儲存設為值 `CHARLIE`。 假設該運行花費了 187 份燃料，所以剩下的燃料數量是 1150 - 187 = 963 份燃料。
6. 增加發送者帳號 963 \* 0.001 = 0.963 個以太幣，同時傳回產生的狀態。

如果交易的接收一端沒有合約，那麼總交易費就等於提供的 `GASPRICE` 乘以交易的位元組長度，且與隨交易發送的資料無關。

請注意，訊息在回滾方面與交易相同：如果訊息執行耗盡燃料，那麼該訊息的執行以及該執行觸發的所有其他執行都會回滾，但父執行不需要回滾。 這意味著合約調用另一份合約是“安全的”，就好像 A 使用 G 份燃料調用 B，那麼可以保證 A 的執行最多損耗 G 份燃料。 最後請注意，有一個建立合約的操作碼 `CREATE`；它的執行機制通常類似於 `CALL`，不同之處在於執行的輸出決定了新建立合約的程式碼。

### 程式碼執行 {#code-execution}

以太坊合約中的程式碼是用一種基於堆疊的低階字節碼語言編寫，被稱為「以太坊虛擬機器程式碼」或「EVM 程式碼」。 該程式碼由一系列位元組組成，每個位元組代表一種操作。 通常，程式碼執行是一個無限循環，即重複執行目前程式計數器（從零開始）處的操作，然後將程式計數器增加一，直到程式碼執行完畢或出現錯誤，或偵測到`STOP` 或`RETURN` 指令 。 操作可以存取三種資料儲存空間：

- **堆疊**，一種後進先出容器，值可以在其中入棧和出棧
- **記憶體**，一個可無限擴充的位元組數組
- 合約的長期**儲存**，一個鍵/值儲存。 與堆疊和記憶體會在計算結束後重置不同，儲存將長期持續存在。

程式碼可以存取傳入訊息的值、發送者資訊和數據，可以存取區塊頭數據，而且程式碼還可以傳回數據位元組數組作為輸出。

以太坊虛擬機碼的正式執行模型簡單得令人吃驚。 當以太坊虛擬機器運行時，其完整計算狀態可以由元組`(block_state, transaction, message, code, memory, stack, pc, gas)` 來定義，其中`block_state` 是包含所有帳戶的全域狀態並 包括餘額和儲存。 在每一輪執行開始時，可以透過呼叫`code` 的第`pc` 個位元組（或如果`pc >= len(code)`，則呼叫0）來找到目前指令，並且每個指令在元 組影響方式方面都有自己的定義。 例如，`ADD` 將兩個項目出棧並將它們的和入棧，將`gas` 減少1 並將`pc` 增加1，`SSTORE` 將頂部的兩個項目出棧並將第二個項目 插入到合約儲存中第一個項目指定的索引處。 儘管有許多透過 JIT 編譯來優化以太坊虛擬機器執行的方法，但只需幾百行程式碼就可以完成以太坊的基本實作。

### 區塊鏈與挖礦 {#blockchain-and-mining}

![以太坊應用框圖](./ethereum-apply-block-diagram.png)

以太坊區塊鏈在許多方面與比特幣區塊鏈相似，但確實存在一些差異。 以太坊和比特幣在區塊鏈架構方面的主要區別在於，與比特幣不同，以太坊區塊包含交易清單和最新狀態的副本。 此外，其他兩個值、區塊編號和難度也儲存在區塊中。 以太坊中的基本區塊驗證演算法如下：

1. 檢查被引用的前一個區塊是否存在並且有效。
2. 檢查區塊的時間戳記是否大於被引用的前一個區塊的時間戳，並且在將來 15 分鐘以內。
3. 檢查區塊編號、難度、交易根、叔根和燃料限制（各種以太坊特定的低階概念）是否有效。
4. 檢查區塊上的工作量證明是否有效。
5. 令前一個區塊末的態為 `S[0]`。
6. 令區塊的交易清單為 `TX`，並包含 `n` 筆交易。 對於 `0...n-1` 中的所有 `i`，設定 `S[i+1] = APPLY(S[i],TX[i])`。 如果任何應用程式傳回錯誤，或直到此時區塊中消耗的總燃料量超過 `GASLIMIT`，則傳回錯誤。
7. 令 `S_FINAL` 為 `S[n]`，但添加支付給礦工的區塊獎勵。
8. 檢查狀態 `S_FINAL` 的默克爾樹根是否等於區塊頭中提供的最終狀態根。 如果等於，則該區塊有效；否則該區塊無效。

這種方法乍看之下效率似乎極低，因為它需要儲存每個區塊的全部狀態，但實際上效率應該與比特幣相當。 原因是狀態儲存在樹結構中，而且在添加每個區塊後只需要更改樹的一小部分。 因此一般來說，在兩個相鄰區塊之間，樹的絕大部分應該是相同的，因此資料可以用指標（即子樹的雜湊）儲存一次和引用兩次。 一種稱為“帕特里夏樹”的特殊類型的樹用於實現此目的，它包括對默克爾樹概念的修改，允許高效地插入和刪除節點，而不僅僅是更改。 此外，由於所有狀態資訊都存在於最後一個區塊內，因此無需儲存整個區塊鏈歷史，如果可以應用於比特幣，使用此策略計算可以節省 5-20 倍空間。

一個常見的問題是合約程式碼在實體硬體的「哪裡」執行。 這個問題有一個簡單的答案：合約程式碼的執行過程是狀態轉換函數定義的一部分，而該函數是區塊驗證演算法的一部分，因此如果將交易添加到區塊`B` 中，由該交易產生的 程式碼執行將在現在和將來由所有節點執行，由此下載並驗證區塊`B`。

## 應用程式 {#applications}

通常，以太坊上有三種類型的應用。 第一類是金融應用，提供使用者更有效的方式來使用資金管理和簽訂合約。 包括子貨幣、金融衍生性商品、對沖合約、儲蓄錢包、遺囑，甚至最終包括某些類別的完整僱傭合約。 第二類是半金融應用，它們涉及金錢，但很大一部分功能也與資金無關；一個恰當的例子是針對解決計算難題的自動執行的賞金。 最後還有一些應用與金融毫不想關，例如線上投票和去中心化治理。

### 代幣系統 {#token-systems}

區塊鏈上的代幣系統有許多應用，從代表美元或黃金等資產的子貨幣到公司股票等等，單一代幣可以代表智慧資產、不可偽造的安全優惠券，甚至可代表作為激勵積分系統 並與傳統價值完全沒有關聯的代幣系統。 代幣系統在以太坊中非常容易實現，讓人吃驚。 要理解的重點是，從根本上講，所有貨幣或代幣系統都是具有這樣一種操作的資料庫：從A 中減去X 個單位並將X 個單位添加給B，條件是(1) A 在交易前至少有X 個單位且(2) 交易由A 批准。 實現代幣系統所需要做的就是將此邏輯實現到合約中。

使用 Serpent 语言实现代币系统的基本代码如下所示：

```py
def send(to, value):
  if self.storage[msg.sender] >= value:
    self.storage[msg.sender] = self.storage[msg.sender] - value
    self.storage[to] = self.storage[to] + value
```

此程式碼本質上是本文檔前面部分詳細描述的「銀行系統」狀態轉換函數的字面實作。 需要額外添加幾行程式碼來規定在最初以及其他一些特殊情況下分配貨幣單位的初始步驟，理想情況下，應該添加一個函數讓其他合約查詢地址的餘額。 但這就足夠了。 理論上，基於以太坊的代幣系統在作為子貨幣時可能具有另一個重要特徵，該特徵是基於比特幣的鏈上元貨幣所缺乏的，那就是直接以該貨幣支付交易費的能力。 實現這一點的方式是：合約會保持一定數量的以太幣餘額，用來向發送者退還用於支付費用的以太幣；合約也會透過收取費用來收集內部貨幣，並在持續不斷的拍賣中轉售 貨幣，以此補充以太幣餘額。 因此，用戶需要用以太幣「啟動」他們的帳戶，但一旦帳戶中有以太幣，就可以重複使用，因為合約每次都會向帳戶退還資金。

### 金融衍生性商品與價值穩定的貨幣 {#financial-derivatives-and-stable-value-currencies}

金融衍生性商品是「智能合約」最常見的應用，也是透過程式碼實現的最簡單的應用之一。 實現金融合約的主要挑戰在於，其中大多數合約都需要引用外部價格自動收報機；例如，一個非常理想的應用是對沖以太幣（或其他加密貨幣）相對於美元波動的智慧合約，但對沖需要合約 知道以太幣/美元的價值。 要實現這一點，最簡單的方法是藉助由特定方（例如納斯達克）維護的「資料饋送」合約，這種合約的設計使得特定方能夠根據需要更新合約並提供一個接口，允許其他合約 向該合約發送訊息並傳回包含價格的回應。

鑑於此關鍵因素，對沖合約將如下所示：

1. 等待 A 方輸入 1000 個以太幣。
2. 等待 B 方輸入 1000 個以太幣。
3. 在儲存中記錄 1000 個以太幣的美元價值（透過查詢資料饋送合約計算得出），假設價值是 $x。
4. 30 天后，允許 A 或 B「重新啟動」該合約，以便將價值 $x 的以太幣（透過再次查詢資料饋送合約獲取新價格並且計算）發送給 A，剩餘以太幣發送給 B。

這種合約在加密貨幣交易中潛力巨大。 加密貨幣的主要問題之一是它的波動性。 儘管許多用戶和商家可能希望獲得處理加密資產的安全性和便利性，但他們中許多人不希望面臨在一天內資金價值損失 23% 的景象。 迄今為止，最常見的解決方案是發行人支持的資產；其想法是發行人創建一種子貨幣，他們有權發行和撤銷這種子貨幣單位，並且發行人可以向給他們（離線）提供一個單位指定 基礎資產（例如黃金、美元）的任何人提供一個單位的貨幣。 然後，發行人承諾向返還一個單位加密資產的任何人提供一個單位基礎資產。 這種機制使得任何非加密資產「升級」為加密資產，前提是發行人是可信的。

但實際上，發行人並不總是值得信賴，在某些情況下，銀行基礎設施過於薄弱或過於不友好，以至於無法提供此類服務。 金融衍生品提供了一種替代方案。 在這種方案中，不是由單一發行人提供資金來支持資產，而是由一個去中心化的投機者市場承擔了這個角色，他們押注加密參考資產（例如以太幣）的價格會上漲。 與發行人不同，投機者無法在交易中違約，因為對沖合約託管他們的資金。 請注意，這種方法不是完全去中心化的，因為仍然需要一個可信來源提供價格自動收報機，但可以說在降低基礎設施要求（與成為發行者不同，發布價格饋送不需要許可證並且可能 被歸類為自由言論）以及減少詐欺的可能性方面，這仍是一次巨大的改進。

### 身分認同與信譽系統 {#identity-and-reputation-systems}

最早的替代加密貨幣[域名幣](http://namecoin.org/)嘗試使用類似比特幣的區塊鏈提供一種名稱註冊系統，透過該系統，用戶可以在公共資料庫中註冊他們的姓名和 其他數據。 主要用例是[DNS](https://wikipedia.org/wiki/Domain_Name_System) 系統，它將諸如“bitcoin.org”等域名（在域名幣的情況下，“bitcoin.bit”）映射到一個IP 地址 。 其它用例包括電子郵件身份驗證系統和可能更先進的信譽系統。 下面是一個基礎合約，它在以太坊中提供與域名幣類似的名稱註冊系統：

```py
def register(name, value):
  if !self.storage[name]:
    self.storage[name] = value
```

該合約非常簡單；它完全是以太坊網路中的一個資料庫，可以向其中添加但不能修改或移除。 任何人都可以把名稱註冊為一個值，該註冊將永久保存。 更複雜的名稱註冊合約還包含一個「函數子句」以及一個機制，前者允許其他合約查詢它，後者允許名稱的「所有者」（即第一個註冊者）更改資料或轉讓所有權。 甚至可以在該合約上添加信譽和信任網路功能。

### 去中心化檔案儲存 {#decentralized-file-storage}

過去幾年，大批受歡迎的線上文件儲存新創公司不斷湧現，其中最著名的是 Dropbox。 Dropbox 想讓用戶可以上傳硬碟備份、提供備份儲存服務並允許用戶存取備份，而用戶需按月付費。 然而，在這一點上，文件儲存市場有時效率相對較低。 在粗略了解各種現有解決方案後會發現，主流文件存儲的每月價格比整個硬碟的成本還要高，特別是在被稱為“恐怖谷”的20-200 GB 級別，既沒有免費 額度也沒有企業級折扣。 以太坊合約讓去中心化文件儲存生態系統得以發展，個人用戶可以在該系統中將自己的硬碟租出去以獲得少量收益，而未使用的空間可用於進一步降低文件儲存的成本。

這個系統的基礎性構件就是我們所謂的「去中心化 Dropbox 合約」。 該合約的工作原理如下。 首先，用戶將需要儲存的資料拆分成幾個區塊並對每個區塊加密以保護隱私，然後以此建構一個梅克爾樹。 然後創建一個包含以下規則的合約，對於每N 個區塊，合約將從默克爾樹中選擇一個隨機索引（使用能夠被合約程式碼存取的上一個區塊的哈希作為隨機性來源），然後 給予第一個實體X 個以太幣，以提供具有簡化支付確認（例如證明樹中特定索引處區塊的所有權）的交易。 當用戶想要重新下載他們的文件時，可以使用微支付通道協議（例如每32 KB 支付1 個szabo）收回文件；最節省費用的方法是支付者不到最後不發布交易，而是每32 KB 之後 ，用一個更划算的具有相同nonce 的交易取代原來的交易。

該協議的一個重要特點是，雖然似乎用戶相信許多隨機節點不會丟失文件，但可以透過以下方法將這種風險降低到接近零：透過私鑰共享將文件拆分成許多部分，並透過監控 合約確定每一部分仍在某個節點中。 如果合約仍在支付款項，則提供了一個加密證明，證明有人仍在儲存該文件。

### 去中心化自治組織 {#decentralized-autonomous-organizations}

通常意義上「去中心化自治組織」是指擁有一定數量成員或股東的虛擬實體，他們大概擁有 67% 的大多數股權，有權使用實體的資金並修改其代碼。 成員集體決定組織的資金分配方式。 去中心化自治組織的資金分配方式可以是獎金、薪資或更奇特的機制等等，例如用內部貨幣去獎勵工作。 這在本質上複製了傳統公司或非營利組織的合法手段，但僅使用加密區塊鏈技術進行了加強。 目前為止，許多關於去中心化自治組織的討論都圍繞著去中心化自治公司的“資本家”模式，其中有可獲得紅利的股東和可交易的股份；作為替代方案，有一種可能被稱為“ 去中心化自治社群」的實體將使所有成員在決策時擁有同等權利，並在增減成員時要求67% 的現有成員多數同意。 由於每個人只能擁有一個成員資格，所以需要群體來集體執行。

以下概括如何用程式碼實現去中心化自治組織。 最簡單的設計就是一段自動修改的程式碼，如果三分之二的成員同意更改，程式碼就會更改。 理論上程式碼是不可更改的，然而透過把程式碼片段放入不同的合約並將合約調用的位址儲存在可更改的儲存中，用戶可以輕易解決這一問題，使程式碼事實上變得可修改。 在這種去中心化自治組織合約的簡單實現中，有三種交易類型，可透過交易中提供的資料行區分：

- `[0,i,K,V]` 在索引 `i` 處註冊提案，以便將儲存索引 `K` 的位址變更為值 `V`
- `[1,i]` 註冊一張贊成提案 `i` 的投票
- `[2,i]` 若投票有足夠票數，則確認提案 `i`

合約為每一種交易都提供有子句。 它將維護所有開放儲存變更的記錄以及投票支持者的清單。 合約還包括所有成員的清單。 當任何儲存變更獲得三分之二成員投票贊成時，一個確認交易將執行此變更。 更複雜的框架可能還有針對發送交易、增減成員等功能的內建投票功能，甚至可以提供[委任式民主](https://wikipedia.org/wiki/Liquid_democracy)投票委託（即任何人都可以 委託另外一個人代表自己投票，而這種委託關係是可以傳遞的，如果A 委託了B，然後B 委託了C，那麼C 將決定A 的投票）。 這種設計將使去中心化自治組織作為一個去中心化社區有機地成長，允許人們最終將篩選成員的任務委派給專家，但與「現有系統」不同，隨著時間的推移，當個別社區 當成員改變他們的陣營時，專家可以輕鬆地加入或退出。

另一個模型是去中心化公司，其中任何帳戶可以擁有零份或多份股份，決策需要持有三分之二多數股份。 完整框架將包括資產管理功能，即能夠出價購買或出售股份並且能夠接受報價（最好是合約裡有訂單匹配機制）。 委託也提供委任制民主形式，普及了「董事會」的概念。

### 更多應用程式 {#further-applications}

**1. 儲蓄錢包**。 假設 Alice 想安全地保管她的資金，但她擔心自己的私鑰遺失或被破解。 她把以太幣放到和銀行 Bob 簽訂的一個合約裡，如下：

- Alice 每天最多可以單獨提取 1% 的資金。
- Bob 每天最多可以單獨提取 1% 的資金，但 Alice 可以用她的金鑰創建一個交易取消 Bob 的提取權限。
- Alice 和 Bob 一起可以任意提領資金。

通常，每天 1% 的額度對於 Alice 來說足夠了，如果 Alice 想提取更多資金，她可以聯繫 Bob 尋求幫助。 如果 Alice 的金鑰被破解，她可以立即找到 Bob，幫她將資金轉移到新合約。 如果 Alice 遺失了金鑰，Bob 最終會取出資金。 如果最終發現 Bob 是惡意的，她可以取消他的提取權限。

**2. 作物保險**。 用戶可以輕鬆地訂購金融衍生性合約，但使用的是天氣而不是任何價格指數的數據饋送。 如果愛荷華州的農民購買了一項金融衍生品，該產品基於愛荷華的降雨情況進行反向賠付，那麼如果遇到乾旱，該農民將自動收到賠付資金，而且如果降雨充沛 ，他會很開心，因為他的作物收成會很好。 通常，這種保險可以擴展到自然災害保險。

**3. 去中心化資料饋送**。 對於金融差價合約，實際上有可能透過一種名為「[謝林幣](http://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/)」的協議將資料饋送去中心化。 謝林幣的基本工作原理如下。 N 個相關方都向系統輸入給定資料的值（以太幣/美元價格），對這些值進行排序，在第 25 和第 75 個百分位之間的每個人都會得到一個代幣作為獎勵。 每個人都有動力提供其他人都會提供的答案，而唯一能讓眾多參與者實際達成一致的值是顯而易見的：真相。 這樣就創造了一種去中心化的協議，它理論上可以提供任何數量的價值，包括以太幣/美元的價格、柏林的溫度、甚至某個硬計算的結果。

**4. 智慧多重簽章託管**。 比特幣允許多重簽名交易合約，例如，提供了給定五個金鑰中的三個便可以使用資金。 以太坊允許更精細的控制；例如，提供五個密鑰中的四個可以使用任意數額的資金，提供五個密鑰中的三個可以每天最多使用10% 的資金，提供五個密鑰中 的兩個可以每天最多使用0.5% 的資金。 此外，以太坊的多重簽名是非同步的 — 雙方可以在不同時間在區塊鏈上註冊他們的簽名，最後一個簽名將自動發送交易。

**5. 雲端運算**。 以太坊虛擬機技術也可以用來創造一個可驗證的運算環境，讓使用者可以要求他人執行計算，然後選擇性地要求證明，證實計算在某些隨機選定的檢查點處正確完成。 這可以創造一個雲端運算市場，任何使用者都可以用他們的桌上型電腦、筆記型電腦或專用伺服器來參與，並且抽查與保證金雙管齊下確保系統是值得信賴的（即節點不能透過欺騙獲利）。 但是，這樣的系統可能不適合所有任務；例如，需要進行大量進程間通訊的任務無法在大型節點雲端上輕易實現。 然而，其他任務則更容易實現並行；例如 SETI@home、folding@home 和遺傳演算法等項目可以輕鬆地在這類平台上實現。

**6. 點對點賭博**。 任意數量的點對點賭博協議都可以在以太坊區塊鏈上實現，例如Frank Stajano 和Richard Clayton 的[Cyberdice](http://www.cl.cam.ac.uk/~fms27/papers/2008-StajanoCla-cyberdice.pdf)。 最簡單的賭博協議實際上只是關於下一個區塊哈希的差價合約，並且可以在其基礎上創建更高級的協議，創建接近零費用且無法作弊的賭博服務。

**7. 預測市場**。 如果有預言機或謝林幣，預測市場也很容易實現，預測市場與謝林幣一起有可能被證明是[futarchy](http://hanson.gmu.edu/futarchy.html) 的第一個 主流應用，作為去中心化組織的治理協議。

**8. 鏈上去中心化市場**，基於身份和信譽系統。

## 雜項與關注 {#miscellanea-and-concerns}

### 改進版 GHOST 協定的實作 {#modified-ghost-implementation}

「貪婪最重可觀察子樹」(GHOST) 協議是由Yonatan Sompolinsky 和Aviv Zohar 在[2013 年12 月](https://eprint.iacr.org/2013/881.pdf)首次提出的創新 。 提出GHOST 的動機是，具有快速確認時間的區塊鏈目前由於過時率高而安全性降低— 因為區塊需要一定的時間才能透過網路傳播，如果礦工A 開採了一個區塊，然後礦工B 碰巧在 礦工A 的區塊傳播到B 之前開採了另一個區塊，那麼礦工B 的區塊最終會被作廢，不會增加網路安全。 此外，還有一個中心化問題：如果礦工A 是一個擁有30% 算力的礦池，而B 擁有10% 算力，那麼A 將面臨70% 的時間生產陳腐區塊的風險（因為在其他30 % 的時間A 產生了最後一個區塊，所以會立即獲得挖礦數據），而B 將面臨90% 的時間生產陳腐區塊的風險。 因此，如果區塊間隔短到足以使過時率較高，則 A 將僅憑藉其規模而顯著提高效率。 結合這兩種影響，快速產生區塊的區塊鏈很可能造就一個擁有足夠高比例網路算力的礦池，從而對挖礦過程擁有事實上的控制。

正如Sompolinsky 和Zohar 所描述的，GHOST 透過在計算哪條鏈「最長」時包含陳腐區塊來解決第一個問題- 網路安全降低；也就是說，在計算哪個區塊具有最大的總工作量 當證明支援它時，不僅區塊的父塊和更遠的祖先，而且該區塊祖先（在以太坊行話中稱為“叔塊”）的陳腐子代也都被添加到計算中。 為了解決第二個問題- 中心化偏差，我們跳出了Sompolinsky 和Zohar 描述的協議範疇，並且還為陳腐區塊提供區塊獎勵：陳腐區塊獲得其基礎獎勵的87.5%，而包含陳腐區塊的 侄塊獲得剩餘的12.5%。 不過，交易費不獎勵給叔塊。

以太坊實現了一個簡化版的 GHOST 協議，它僅僅深入七個層級。 具體而言，它的定義如下：

- 一個區塊必須指定一個父區塊，並且必須指定零個或多個叔區塊
- 包含在區塊 B 中的叔塊必須具有以下屬性：
  - 它必須是區塊 B 的第 k 代祖先的直系子代，其中 2 <= k <= 7。
  - 它不能是 B 的祖先
  - 叔塊必須是有效的區塊頭，但不需要是之前驗證過的甚至是有效的區塊
  - 叔塊必須不同於前面區塊中包含的所有叔塊，並且不同於同一區塊中包含的所有其他叔塊（非雙重包含）
- 對於區塊 B 中的每個叔塊 U，區塊 B 的礦工獲得額外 3.125% 的鑄幣獎勵，而叔塊 U 的礦工獲得 93.75% 的標準鑄幣獎勵。

這種限製版的 GHOST 協議，最多只能包含 7 代叔塊，採用它有兩個原因。 首先，無限制 GHOST 協議讓計算給定區塊的哪些叔塊有效時過於複雜。 其次，無限制 GHOST 協議採用了以太坊中使用的補償，取消了促使礦工在主鏈而不是公共攻擊者的鏈上挖礦的激勵措施。

### 費用 {#fees}

由於發佈到區塊鏈中的每筆交易都會為網路帶來下載和驗證成本，因此需要一些監管機制（通常涉及交易費用）以防濫用。 比特幣中使用的預設方法是收取完全自願性質的費用，依靠礦工充當守門人並設定動態最低費用。 這種方法在比特幣社區中非常受歡迎，特別是因為它是“基於市場的”，允許由礦工和交易發送者之間的供需決定價格。 然而，這種想法的問題在於，交易處理並不符合市場法則。 儘管將交易處理解釋為礦工向發送者提供的服務直觀上很有吸引力，但實際上礦工收錄的每筆交易都需要由網絡中的每個節點處理，因此絕大部分交易處理成本由第三方 承擔，而非由決定是否收錄交易的礦工承擔。 因此，公地悲劇的問題很可能發生。

然而結果卻是，基於市場機制中的這個缺陷，在給出一個不準確的特定簡化假設時，會神奇地自我抵銷。 論證如下。 假設：

1. 交易導致 `k` 個操作，將提供獎勵 `kR` 給收錄它的任何礦工，其中 `R` 由發送者設置，`k` 和 `R` 事先（大體上）對礦工可見。
2. 操作在任何節點的處理成本為 `C`（即所有節點效率相同）
3. 有 `N` 個挖礦節點，每個節點的處理能力完全相同（即為總處理能力的 `1/N`）
4. 沒有不挖礦的完整節點。

如果預期獎勵大於成本，礦工將願意處理交易。 因此，預期獎勵是 `kR/N`，因為礦工有 `1/N` 幾率處理下一個區塊，而礦工的處理成本只是 `kC`。 所以，當 `kR/N > kC` 或 `R > NC` 時，礦工將會收錄交易。 請注意，`R` 是發送者提供的每個操作的費用，因此是發送者從交易中獲得的收益的下限，`NC` 是整個網路共同處理一個操作的成本。 因此，礦工有動機只收錄那些總實際收益超過成本的交易。

然而，現實中這些假設會存在幾個重要偏差：

1. 與其他驗證節點相比，礦工處理交易的成本確實更高，因為額外的驗證時間會延遲區塊傳播，從而增加區塊變陳腐的幾率。
2. 確實存在不挖礦的完整節點。
3. 實際中挖礦能力的分配最終可能極度不平等。
4. 熱衷於破壞網路的投機者、政敵和瘋子確實存在，他們可以巧妙地設定合約，使得他們的成本遠低於其他驗證節點支付的成本。

(1) 讓礦工趨向於收錄較少的交易，並且 (2) 增加 `NC`；因此，這兩種作用會相互抵銷 一部份 。 <sup>[如何抵消？ ](https://github.com/ethereum/wiki/issues/447#issuecomment-316972260)</sup> (3) 和(4) 是主要問題，為了解決它們，我們簡單地訂定了一個浮動上限： 沒有區塊能夠包含比`BLK_LIMIT_FACTOR` 乘以長期指數移動平均值更多的操作數。 具體如下：

```js
blk.oplimit = floor(
   (blk.parent.oplimit * (EMAFACTOR - 1) +
     floor(parent.opcount * BLK_LIMIT_FACTOR)) /
     EMA_FACTOR
)
```

`BLK_LIMIT_FACTOR` 和 `EMA_FACTOR` 是常數，暫時設定為 65536 和 1.5，但可能會在進一步分析後變更。

還有一個因素會抑制比特幣中的大區塊大小：大區塊將需要更長時間來傳播，因此變陳腐的機率更高。 在以太坊中，燃料消耗量高的區塊也可能需要更長的傳播時間，因為它們的物理大小更大，而且因為它們需要更長時間來處理交易狀態轉換以進行驗證。 這種延遲抑制因素在比特幣中是一個重要的考慮因素，但在以太坊中由於 GHOST 協議而較少考慮；因此，依靠受監管的區塊限制可提供更穩定的基線。

### 計算與圖靈完備 {#computation-and-turing-completeness}

重要的一點是，以太坊虛擬機器是圖靈完整的；這意味著以太坊虛擬機器程式碼可以對任何設想可執行的計算進行編碼，包括無限循環。 以太坊虛擬機器程式碼以兩種方式實現循環。 首先，使用一個`JUMP` 指令，允許程式跳回至程式碼中的前一個位置，也使用一個`JUMPI` 指令進行條件跳轉，允許諸如`while x < 27: x = x * 2` 之類的 語句。 其次，合約可以呼叫其他合約，有可能透過遞歸進行循環。 這很自然地導致了一個問題：惡意使用者能夠透過迫使礦工和完整節點進入無限循環而不得不關機嗎？ 這個問題的出現源自於電腦科學中的一個難題，稱為停機問題：在一般情況下，沒有辦法知道一個特定的程式是否會停止運作。

如狀態轉換部分所述，我們的解決方案要求交易設定一個允許執行的最大計算步驟數，如果超過執行時間，計算就會被回滾，但仍要支付費用。 訊息的工作原理相同。 為顯示我們解決方案背後的動機，請看下面的範例：

- 攻擊者創建一個運行無限循環的合約，然後向礦工發送激活該循環的交易。 礦工將處理該交易，運行無限循環直到燃料耗盡。 即使執行耗盡了燃料並中途停止，交易仍然有效，礦工仍然向攻擊者索取每個計算步驟的費用。
- 攻擊者創建一個非常長的無限循環，目的是迫使礦工持續計算很長時間，以至於計算結束時，將有更多區塊產生出來，這樣礦工就不可能透過收錄該交易來索取費用。 然而，攻擊者需要為 `STARTGAS` 提交一個值，限制執行可以進行的計算步驟數，因此礦工將提前知道該計算將進行相當多的步驟數。
- 攻擊者看到一個合約，其中的代碼形式為`send(A,contract.storage[A]); contract.storage[A] = 0`，然後發送一個交易，但燃料只夠運行第一步而 不足以運行第二步（即進行提款但不讓餘額減少）。 合約作者無需擔心防衛此類攻擊，因為如果執行中途停止，更改會被回滾。
- 金融合約使用九個專有資料饋送的中位數，以便最大限度地降低風險。 攻擊者接管其中一個資料饋送，該資料饋送設計為可通過去中心化自治組織部分描述的變數-地址-調用機制修改，並將其轉換為運行無限循環，從而強制任何從金融合約索取資金的嘗試 都因燃料耗盡而中止。 然而，金融合約可以為訊息設定一個燃料限制，防止這個問題發生。

圖靈完備的替代方案是圖靈不完備，其中 `JUMP` 和 `JUMPI` 不存在，並且在任何給定時間每個合約只允許有一個副本存在於調用堆疊內。 在這樣的系統裡，上述收費系統和關於我們解決方案效果的不確定性可能都是不必要的，因為執行一個合約的成本將被它的大小決定。 此外，圖靈不完備甚至不是一個很大的限制；在我們內部構想的所有合約範例中，到目前為止只有一個需要循環，甚至那個循環也可以透過將一行程式碼重複 26 次來消除。 考慮到圖靈完備帶來的嚴重影響和有限的益處，為什麼不簡單地使用一種圖靈不完備語言呢？ 然而，在現實中，圖靈不完備還遠遠不能有效地解決問題。 要知道原因，請思考以下合約：

```sh
C0: call(C1); call(C1);
C1: call(C2); call(C2);
C2: call(C3); call(C3);
……
C49: call(C50); call(C50);
C50: (run one step of a program and record the change in storage)
```

現在，向 A 發送一筆交易。 這樣，在 51 筆交易中，我們有一個合約需要進行多達 2<sup>50</sup> 個計算步驟。 礦工可以嘗試提前檢測這種邏輯炸彈，方法是為每個合約維護一個值，指定合約可以進行的最大計算步驟數，然後對遞歸調用其他合約的合約進行計算，但是這需要礦工禁止創建其他合約的 合約（因為上面26 個合約的建立和執行可以很容易地匯集到一個單獨合約內）。 另一個問題是，訊息的位址欄位是一個變量，所以在一般情況下，甚至不可能提前知道某個合約將調用哪些其他合約。 於是，最終我們有了一個驚人的結論：圖靈完備的管理驚人地容易，而在缺乏同樣的控制時圖靈不完備的管理驚人地困難，那為什麼不直接讓協議圖靈完備呢？

### 貨幣與發行 {#currency-and-issuance}

以太坊網路包括自己的內建貨幣以太幣，以太幣扮演雙重角色：提供一個主要流動資金層，實現各種數位資產之間的高效交易；更重要的是，提供一種支付交易費的機制。 為了方便起見並避免將來出現爭議（參考比特幣當前的 mBTC、uBTC、satoshi 論點），不同面值的名稱將提前設定如下：

- 1: wei
- 10<sup>12</sup>：Szabo
- 10<sup>15</sup>：finney
- 10<sup>18</sup>：ETH

這應該被視為“美元”和“美分”或“BTC”和“satoshi”概念的擴展版本。 在不久的將來，我們期望“ETH”用於普通交易，“finney”用於微型交易，“szabo”和“wei”可以在圍繞費用和協議實現的技術討論中使用；其餘的面額可能會在以後 變得有用，但目前不應包含在客戶端中。

發行模型如下：

- 以太幣將以貨幣銷售的形式發行，價格為一個比特幣可購買1000-2000 個以太幣，這種機制旨在為以太坊組織籌資和支付開發費用，且已被其他平台（如Mastercoin 和NXT ）成功應用。 早期的購買者將從較大的折扣中獲益。 發售所得的比特幣將全部用來支付開發者的薪資和獎金，並用來投資以太坊和加密貨幣生態系統中的各種營利和非營利項目。
- 0.099 倍的發售總量（60102216 個以太幣）將分配給以太坊組織，以補償早期貢獻者，並用以太幣計價的方式支付創世塊誕生前的開銷。
- 0.099 倍的發售總量將保留為長期儲備金。
- 發售後，將永久地每年為礦工分配 0.26 倍的發售總量。

| 分組 | 啟動時 | 一年後 | 5 年後 |
| ------------------ | ------ | ------ | ------ |
| 貨幣單位 | 1.198X | 1.458X | 2.498X |
| 購買者 | 83.5% | 68.6% | 40.0% |
| 已支用的預售準備金 | 8.26% | 6.79% | 3.96% |
| 已使用的售後準備金 | 8.26% | 6.79% | 3.96% |
| 礦工 | 0% | 17.8% | 52.0% |

#### 長期供應成長率（百分比）

![以太坊通貨膨脹](./ethereum-inflation.png)

_儘管採用了線性發行方式，然而和比特幣一樣，以太幣的長期供應增長率也趨於零。_

上述模型提供了兩個主要選項：(1) 捐贈池的存在和規模，以及 (2) 永久增長的線性供應的存在，而比特幣採用了限制供應的方法。 捐贈池存在的理由如下。 如果捐贈池不存在，並且線性發行量減少到總發售量的 0.217 倍以實現相同的通貨膨脹率，那麼以太幣總量將減少 16.5％，而每個單位的價值將增加 19.8％。 因此為了均衡，將會多發售 19.8% 的以太幣，所以每個單位的價值將再次與以前完全一樣。 之後，該組織還將擁有 1.198 倍的比特幣，可以考慮將其分成兩部分：原有的比特幣和增加的 0.198 倍比特幣。 因此，這種情況*完全等同於*捐贈，但有一個重要區別：組織僅持有比特幣，因而沒有動力支持以太幣單位的價值。

永久性線性供應成長模型降低了有些人認為比特幣財富過度集中的風險，並為生活在當前和未來的人提供了獲取貨幣單位的公平機會，同時又保留了讓人獲取並持有以太幣的 強效激勵措施，因為長期來看，用百分比表示的「供應成長率」將趨於零。 我們還推測，由於加密貨幣總是會因為不小心、死亡等原因而丟失，而加密貨幣的損失可以被模擬為每年總供應量的百分比，因此流通中的貨幣總供應量實際上最終會穩定在 一個等於每年發行量除以損失率的數值上（例如，在損失率為1% 時，一旦供應量達到26 倍，那麼每年將有0.26 倍被開採，0.26 倍丟失，形成一個平衡點）。

請注意，未來以太坊可能過渡到權益證明模型以確保安全，將每年發行量降低到 0 至 0.05 倍之間。 如果以太坊組織失去資助或出於任何其他原因而消失，我們將開放一個「社區合約」：任何人都有權創建未來的以太坊候選版本，唯一的條件是太幣數量必須最多為`60102216 * (1.198 + 0.26 * n)` 個，其中`n` 是創世塊產生後的年數。 創建者可以自由地通過眾籌或其他方式，分配權益證明驅動的供應增加與最大允許供應增加之間的部分或全部差額，以支付開發費用。 不符合社區合約的候選版本升級可能被合理地分叉為相容版本。

### 挖礦中心化 {#mining-centralization}

比特幣挖礦演算法的原理是，讓礦工一次又一次地對區塊頭稍作修改的版本進行數百萬次SHA256 計算，直到最終某個節點所產生版本的哈希小於目標值（目前大約為2 <sup>192</sup>）。 然而，這種挖礦演算法容易遭受兩種形式的中心化攻擊。 第一種，挖礦生態系統已經被 ASIC（專用積體電路）所支配，這些電腦晶片專門為特定的比特幣挖礦任務而設計，因此效率提高了數千倍。 這意味著比特幣挖礦不再是一種高度去中心化和平等的事業，需要巨額資本才能有效參與。 第二種，大部分比特幣礦工事實上不在本地完成區塊驗證；而是依賴中心化礦池提供區塊頭。 這個問題可以說更糟：截至撰寫本文時，排名前三的礦池間接控制了比特幣網路中約50% 的處理能力，儘管當礦池或聯盟試圖進行51％ 攻擊時，礦工可以轉換到其他 礦池這一事實緩解了這個問題。

以太坊現在的目的是使用一種挖掘演算法，要求礦工從狀態中獲取隨機數據，從區塊鏈的最後 N 個區塊中計算一些隨機選擇的交易，並傳回結果的哈希值。 這有兩個重要好處。 首先，以太坊合約可以包含任何類型的計算，因此以太坊 ASIC 本質上是用於一般計算的 ASIC，即更好的 CPU。 其次，挖礦需要存取整個區塊鏈，這迫使礦工儲存整個區塊鏈並至少能夠驗證每筆交易。 這樣就消除了對中心化礦池的需求；雖然礦池仍然可以起到平衡獎勵分配隨機性的合法作用，但沒有中心化控制的點對點礦池同樣也可以很好地發揮此功能。

該模型未經測試，在將合約執行作為挖礦演算法使用時，在避免某些巧妙優化的過程中可能會遇到困難。 然而，這種演算法有一個值得注意的特點，任何人都可以透過將專用於抑制某些 ASIC 的大量合約引入區塊鏈中，在「井裡下毒」。 由於存在經濟激勵，ASIC 製造商會使用這種方法互相攻擊。 因此，我們正在開發的解決方案最終是一種適應性人為經濟解決方案，而不是純粹的技術解決方案。

### 可擴充性 {#scalability}

可擴展性問題是以太坊常被關注的一個面向。 像比特幣一樣，以太坊也有缺陷，即網路中的每個節點都需要處理每筆交易。 使用比特幣，目前區塊鏈的大小約為 15 GB，每小時增長約 1 MB。 如果比特幣網路像 Visa 一樣每秒處理 2000 筆交易，它將每三秒增長 1 MB（每小時 1 GB，每年 8 TB）。 以太坊可能也會經歷相似甚至更糟的成長模式，因為以太坊區塊鏈之上還有很多應用，不像比特幣區塊鏈上只有貨幣，但以太坊完整節點只需儲存狀態而不是完整 的區塊鏈歷史，這一事實讓情況得到了改善。

大區塊鏈的問題是中心化風險。 如果區塊鏈大小增加到 100 TB，可能的情況是只有極少數大型企業能運行完整節點，而所有普通用戶將使用輕 SPV 節點。 在這種情況下，可能會出現這樣的擔憂：完整節點合夥詐欺牟利（例如更改區塊獎勵，給他們自己比特幣等）。 輕節點無法立即偵測到這一點。 當然，可能至少存在一個誠實的完整節點，幾個小時之後有關詐騙的資訊會透過Reddit 這樣的管道洩露，但這時已為時過晚：將由普通用戶相互組織協作將指定區塊列入黑名單 ，這種大規模的、很可能不切實際的協作在規模上無異於發動一次成功的51% 攻擊。 就比特幣而言，目前這是一個問題，但[Peter Todd 建議](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/)對區塊鏈進行修改，以緩解此問題。

在短期內，以太坊將使用兩種其他策略來應對這個問題。 首先，因為基於區塊鏈的挖礦演算法，至少每個礦工都會被強製成為一個完整節點，為完整節點的數量創建了一個下限。 其次，更重要的是，處理完每筆交易後，我們會把一個中間狀態樹根收錄到區塊鏈中。 即使區塊驗證是中心化的，只要存在一個誠實的驗證節點，就可以透過驗證協議來規避中心化問題。 如果礦工發布了無效區塊，該區塊必定是格式錯誤，或是狀態 `S[n]` 不正確。 由於已知 `S[0]` 是正確的，因此必然存在第一個不正確的狀態 `S[i]`，但狀態 `S[i-1]` 是正確的。 驗證節點將提供索引`i` 以及“無效證明”，該證明包括處理`APPLY(S[i-1],TX[i]) -> S[i]` 所需的帕特里夏樹節點的 子集。 節點將能夠使用這些節點來運行該部分計算，並查看生成的 `S[i]` 與提供的 `S[i]` 是否不匹配。

另一種更複雜的攻擊涉及惡意礦工發布不完整的區塊，因此甚至不存在完整訊息，致使無法確定區塊是否有效。 解決方案是質詢-應答協議：驗證節點對目標交易索引發起“質疑”，接受到質疑信息的輕節點會對相應的區塊取消信任，直到另外的節點（無論是礦工還是另一個驗證者）提供 一個帕特里夏樹節點子集作為有效性證明。

## 結論 {#conclusion}

以太坊協議最初被設想為加密貨幣的升級版本，透過高度通用的程式語言提供高級功能，如區塊鏈託管、提款限制、金融合約、博彩市場等。 以太坊協議不會直接「支援」任何應用，但圖靈完備程式語言的存在意味著，理論上可以為任何交易類型或應用程式創建任意合約。 然而，關於以太坊更有趣的方面是，以太坊協議遠遠超出了貨幣的範疇。 圍繞去中心化文件儲存、去中心化計算和去中心化預測市場的協議以及許多其他這類概念，有可能大大提高計算行業的效率，並首次通過添加經濟層來大力促進其他點對點協議的發展。 最後，還有大量與金錢完全無關的應用程式。

以太坊協議實現的任意狀態轉換函數的概念提供了一個具有獨特潛力的平台；而不是一種專門針對資料儲存、賭博或金融領域內一系列特定應用的封閉式單用途協議，以太坊在設計上 是開放式的，我們相信在今後幾年中它非常適合作為大量金融和非金融協議的基礎層。

## 註解與延伸閱讀 {#notes-and-further-reading}

### 註解 {#notes}

1. 有經驗的讀者可能會注意到，事實上比特幣地址是橢圓曲線公鑰的哈希，而非公鑰本身。 然而事實上從密碼學術語角度把公鑰哈希稱為公鑰完全合理。 這是因為比特幣密碼學可以視為一種客製化的數位簽章演算法。 在數位簽章演算法中，公鑰由 ECC（橢圓曲線加密演算法）公鑰的雜湊組成，簽章由連接了 ECC 簽章的 ECC 公鑰組成。 而驗證演算法涉及用 ECC 公鑰哈希（作為公鑰提供）來檢查簽章中的 ECC 公鑰，然後用 ECC 公鑰來驗證 ECC 簽章。
2. 技術上來說，前 11 個區塊的中位數。
3. 在內部，2 和 "CHARLIE" 都是數字 <sup>[fn3]（註號）</sup>，後者以大端序基數 256 表示。 數字可以至少 0，最大為 2<sup>256</sup>-1。

### 延伸閱讀 {#further-reading}

1. [內在價值](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/)
2. [智慧資產](https://en.bitcoin.it/wiki/Smart_Property)
3. [智能合約](https://en.bitcoin.it/wiki/Contracts)
4. [B-money](http://www.weidai.com/bmoney.txt)
5. [可重複使用的工作量證明](https://nakamotoinstitute.org/finney/rpow/)
6. [利用所有者權限確保財產權](https://nakamotoinstitute.org/secure-property-titles/)
7. [比特幣白皮書](http://bitcoin.org/bitcoin.pdf)
8. [域名幣](https://namecoin.org/)
9. [佐科三角](https://wikipedia.org/wiki/Zooko's_triangle)
10. [彩色幣白皮書](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)
11. [萬事達幣白皮書](https://github.com/mastercoin-MSC/spec)
12. [去中心化自治公司，比特幣雜誌](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)
13. [簡化付款確認](https://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification)
14. [默克爾樹](https://wikipedia.org/wiki/Merkle_tree)
15. [派翠西亞樹](https://wikipedia.org/wiki/Patricia_tree)
16. [GHOST 協議](https://eprint.iacr.org/2013/881.pdf)
17. [StorJ 和自治代理，Jeff Garzik](http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html)
18. [Mike Hearn 在圖靈節上談論智慧資產](https://www.youtube.com/watch?v=MVyv4t0OKe4)
19. [以太坊遞歸長度前綴編碼 (RLP)](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP)
20. [以太坊默克爾派翠西亞樹](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree)
21. [Peter Todd 論默克爾求和樹](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/)

_有關本白皮書的歷史，請參閱[此維基文章](https://github.com/ethereum/wiki/blob/old-before-deleting-all-files-go-to-wiki-wiki-instead/old-whitepaper-for-historical-reference.md)。_

_和眾多社群驅動的開源軟體專案一樣，以太坊自啟動以來一直不斷發展。 若想了解以太坊的最新進展以及如何更改以太坊協議，我們推薦您閱讀[本指南](/learn/)。_
